---
title: "Modeling Biological Intensity Measurements with Sicegar"
author: "Ethan Ashby"
date: "5/26/2020"
output: pdf_document
---

# Overview

Sigmoidal and Impulse models are S-shaped curves that are descriptive of a variety of biological responses, and are parameterized by biologically meaningful parameters. Particularly, we are interested in how these models can be applied to gene expression measurements over time in response to environmental stimuli.  

Here we focus on an algorithm (Sicegar) for fitting sigmoidal and impulse models to biological intensity measurements. This package was initially developed to fit S-shaped curves to fluorescence generated by GFP produced by viruses as they affected cells. However, this method is purportedly applicable to many high-throughput biological tasks, and hosts a number of advantages compared to the other modeling approach considered (ImpulseDE2). The model fits expression models using least squares and then compares AIC's between a constant fit and the models to determine whether there is any signal. If there is signal, the algorithm proceeds through a 7-step criteria (AIC cutoffs, thresholds for initial and final expression, convergence, etc) to determine if the fit is best described by a sigmoid, impulse, or ambiguous fit. The data we are working with is a 150 minute time-course RNA-sequencing experiment of *E. coli* cells in response to cell starvation. We are particularly interested in the onset time (t_1) parameter of these models, as they can be used as a proxy for when genes are 'turning on' in response to a stimuli and can be used to test the hypothesis that sensitivity/insensitivity to RpoS could be a mechanism for controlling order and timing or gene expression in response to stress.  

My two chief concerns with this method are as follows:  
1. A least squares fitting approach assumes a gaussian (normal) noise structure about the signal. These read count data may adhere to an approximately normal distribution in some cases but not in others (e.x. low counts). Therefore, applying a least squares fitting method to this scenario may be theoretically untenable.
2. This method is only capable of fitting models to upregulated profiles. The code must be adapted to fit downregulated profiles as well.  

The chief benefits of this method are as follows:  
1. The gaussian assumption (while possibly simplistic) is more interepretable and allows for the application of a bunch of statistically well-developed ideas downstream of model fitting. The algorithm outputs standard errors for all the parameters, which can be extremely useful in assessing how much confidence we have in the parameter estimates.
2. The models appear to produce much better fits that the ImpulseDE2 approach, even with random initializations.
3. Sicegar parameterizes the sigmoid model with only 3 parameters, helping to reduce overfitting.  
 
# How to work with Sicegar

Two functions that may be very useful in the sicegar are fitAndCategorize(), which fits a sigmoid and impulse (double sigmoid) model to the data and goes through the decision process to classify the gene as either sigmoid or impulse. figureModelCurves() plots these fits in plots that are compatible with ggplot2.  

It's important to note that Sicegar does all it's modeling on scaled data; the expression and time are both converted to a [0,1] scale. The resulting optimized parameters can be backtransformed to their original units by using scaling parameters in the 'Model' object. Calling this fitted model returns a number of useful things: the parameter estimates, scaling parameters, parameter estimates in the data's actual units, standard errors of the parameter estimates, likelihoods, asymptotes, and more.

```{r Load packages and functions, echo=FALSE, cache=TRUE, warning=FALSE}
library(tidyverse)
library(ImpulseDE2)
library(DESeq2)
library(gridExtra)
library(grid)
library(gridGraphics)
library(reshape2)
library(data.table)
library(knitr)
library(limma)

foo<-function(){}

sigmoid_function<-function(b, h_0, h_1, t_1, t){
h_0 + (h_1-h_0)*(1/(1+exp(1)^(-b*(t-t_1))))
}

impulse_function<-function(b, h_0, h_1, h_2, t_1, t_2, t){
  (1/h_1)*(h_0+(h_1-h_0)/(1+exp(-b*(t-t_1))))*(h_2+(h_1-h_2)/(1+exp(b*(t-t_2))))
}
```

```{r Upstream filtering, cache=TRUE, echo=FALSE, warning=FALSE}
allCounts <- read.csv("LB_Time_Course_GCA_000005845.2_ASM584v2_genomic_counts copy.tsv", header = T, sep = "\t")
allCounts$GeneidBackup = allCounts$Geneid
allCounts <- allCounts %>% tidyr::separate(GeneidBackup, c("feature", "rest"), sep="[:]")
allCounts %>% group_by(feature) %>% summarise(number_of_genes = n())
# Now, we must extract the genenames from each Geneid. However, each feature has a slightly different pattern, and we will need to do the features separately. 

# IGR's (this includes AS_IGRSs): 
# IGR stands for intergenic region which means a region between coding sequences or different types of RNA. Therefore, we'll have a start.bnum and end.bnum as well as a start.genename and end.genename. Note that not all genes will have a bnum (only CDS/AS_CDS do)
bnum = "b[0-9]{4}" # what do bnumbers look like?
genename = ",[a-z]{3}[A-Z,]." # what does a genename look like? this is regexp lingo
rna.name = ",rna[0-9].." # what does an RNA name look like?
igr <- allCounts %>% filter(feature %in% c("IGR", "AS_IGR"))
igr$GeneidBackup = igr$Geneid # store the Geneid
igr <- igr %>% separate(GeneidBackup, c("Geneid1", "Geneid2"), sep = "[/]") # separate the first part of the Geneid which talks about the IGR's start gene (Geneid1) and the last part of the IGR Geneid which talks about that IGR's end gene (Geneid2). 
igr$feature1 <- separate(igr, Geneid1, c("feature1", "rest"), sep = "[,]")$feature1
igr$feature1 <- separate(igr, feature1, c("rest", "feature1"), sep = "[()]")$feature1 #start feature
igr$feature2 <- separate(igr, Geneid2, c("feature2", "rest"), sep = "[,]")$feature2
igr$start.gene <- case_when( #start gene name: many possibilities!
    igr$feature1 == "CDS" ~ str_extract(igr$Geneid1, genename), #if the start feature was CDS, then the name is going to be genename style, so we extract a genename-type thing from Geneid1
    TRUE ~ str_extract(igr$Geneid1, rna.name)) #otherwise, it's going to have an RNA-style name, so we extract the rna.name from Geneid1
igr$end.gene <- case_when( #end gene neame: similar to above!
    igr$feature2 == "CDS" ~ str_extract(igr$Geneid2, genename), # if the end feature was CDS, then we're looking for a genename-type bit from Geneid2
    TRUE ~ str_extract(igr$Geneid2, rna.name)) #otherwise, it must be an RNA-style label of some sort. 
igr$start.bnum <- case_when(
    igr$feature1 == "CDS" ~ str_extract(igr$Geneid1, bnum), #bnums only exist for CDS, so we check if the feature is CDS before extracting a bnum from Geneid1
    TRUE ~ "none") # if not CDS, then no bnum exists so we can put "none"
igr$end.bnum <- case_when(
    igr$feature2 == "CDS" ~ str_extract(igr$Geneid2, bnum), #same thing as above but for end bnum
    TRUE ~ "none")
# now get rid of all those pesky commas that got into our start.gene labels. I could have not included the punctuation in my regex pattern, but then str_extract() might have gotten confused with a less specific pattern
igr <- igr %>% separate(start.gene, into = c("comma", "start.gene"), sep = "[,]") %>% dplyr::select(-comma) %>% separate(end.gene, into = c("comma", "end.gene"), sep = "[,]") %>% dplyr::select(-comma)
allCounts <- full_join(igr, allCounts) #add this new information to allCounts!
# CDS
# have bnum and genename columns
# left join to allCounts
genename = ":[a-z]{3}.." #new genename pattern
#bnum pattern stays the same
cds <- allCounts %>% filter(feature %in% c("AS_CDS", "CDS")) 
cds$genename <- str_extract(cds$Geneid, genename) #extract those genenames!
cds$bnum <- str_extract(cds$Geneid, bnum) # extract them bnums!
#get rid of the pesky colon that was part of the pattern
cds <- cds %>% separate(genename, into = c("colon", "genename"), sep = ":") %>%
  dplyr::select(-colon)
allCounts <- full_join(allCounts, cds) #add the new info to allCounts
#ncRNA
#ncRNA doesn't have bnums, but id's which we'll put in the genename column
rna.name = ":rna[0-9].." #new rna.name pattern
rna <- allCounts %>% filter(feature %in% c("ncRNA", "AS_ncRNA"))
rna$genename <- str_extract(rna$Geneid, rna.name) #record those rna.names
rna <- rna %>% separate(genename, into = c("colon", "genename"), sep = ":") %>%
  dplyr::select(-colon) #get rid of colon
allCounts <- full_join(allCounts, rna) #update allCounts with ncRNA names!
#rRNA
rRNA <- allCounts %>% filter(feature %in% c("rRNA", "AS_rRNA"))
rRNA$genename <- str_extract(rRNA$Geneid, rna.name) #same rna.name pattern exists as above, so extract those rna.names! And store the result as genename - I know. This is just for convenience's sake so we have a common column to refer to when we want the short hand name for a gene. 
rRNA <- rRNA %>% separate(genename, into = c("colon", "genename"), sep = ":") %>%
  dplyr::select(-colon) #get rid of that colon
allCounts <- full_join(allCounts, rRNA) #update allCounts
#tRNA -- analogous to rRNA above. 
tRNA <- allCounts %>% filter(feature %in% c("tRNA", "AS_tRNA"))
tRNA$genename <- str_extract(tRNA$Geneid, rna.name)
tRNA <- tRNA %>% separate(genename, into = c("colon", "genename"), sep = ":") %>%
  dplyr::select(-colon)
allCounts <- full_join(tRNA, allCounts)
# remove the NA rows we just created by full_joining while adding the ncRNA, rRNA, tRNA genenames
allCounts <- filter(allCounts, feature %in% c("IGR", "AS_IGR") | genename != "NA")

#filter by CDS, NA, 0 sums, resolve duplicates
#filter
ecounts<-allCounts %>% filter(feature=="CDS")
#remove NA and rows of 0's
ecounts<-ecounts[rowSums(is.na(ecounts)) != ncol(ecounts), ]
ecounts<-subset(ecounts, rowSums(ecounts[,2:37])>0)
#resolve duplicates (takes the first row corresponding to a genename)
ecounts<- ecounts %>% dplyr::distinct(genename, .keep_all=TRUE)
rownames(ecounts)<-ecounts$genename
ecounts<-ecounts[,2:37]
```

```{r Normalized counts, echo=FALSE, cache=TRUE, warning=FALSE}
colidesign<-data.frame(time=as.factor(rep(c("0", "30", "60", "90", "120", "150"), 6)), rep=as.factor(c(rep(1, 12), rep(2,12), rep(3,12))), treatment=as.factor(c(rep("WT",6), rep("treat",6), rep("WT",6), rep("treat",6), rep("WT",6), rep("treat",6)))) %>%
  mutate(timetreat=paste(treatment, time, sep=""))

ddsecoliCountTable <- DESeqDataSetFromMatrix(
  countData = ecounts,
  colData = colidesign,
  design = ~ timetreat)

#ID'ed 728 DEGs w/ padj<0.01
#ID genes DE over time (0 min to 150 min in WT strain)
ecolidds<-DESeq(ddsecoliCountTable)
normecounts<-as.data.frame(counts(ecolidds, normalized=TRUE))
```

```{r Application, echo=FALSE, cache=TRUE, warning=FALSE}
library(sicegar)
library(gdata)

#load in file with list of sensitive and insenstive genes
sensitivity<-read.xls("Sensitivity.xlsx")
#split the dataframe by sensitivity level
sensitive<-sensitivity %>% filter(sensitivity=="sensitive") %>% dplyr::select(geneName)
linear<-sensitivity %>% filter(sensitivity=="linear") %>% dplyr::select(geneName)
insensitive<-sensitivity %>% filter(sensitivity=="nsRegulation") %>% dplyr::select(geneName)


####
#First crack at dealing with upregulated and downregulated genes
###

#choose gadB
  gene="gadB"
#load counts for that gene
  vecCounts<-unlist(c(normecounts[grep(gene, rownames(normecounts)), grep("JH01", colnames(normecounts))]))
  
  #run model fitting... works very well for gadB (upregulated), poorly for talB (downregulated)
  dat<-data.frame(intensity=vecCounts, time=rep(seq(0,150,30),3))
  Model <- fitAndCategorize(dataInput=dat, threshold_t0_max_int=1E10, threshold_sm_tmax_IntensityRatio = 0.80, threshold_AIC=0)
  if(Model$summaryVector$decision=="ambiguous"){foo()}
  if(Model$summaryVector$decision=="sigmoidal"){a<-figureModelCurves(dataInput=Model$normalizedInput, sigmoidalFitVector = Model$sigmoidalModel, showParameterRelatedLines = TRUE)+ggtitle(paste(gene, "Sigmoidal", sep=" "))}
  if(Model$summaryVector$decision=="double_sigmoidal"){a<-figureModelCurves(dataInput=Model$normalizedInput, doubleSigmoidalFitVector = Model$doubleSigmoidalModel, showParameterRelatedLines = TRUE)+ggtitle(paste(gene, "Impulse", sep=" "))}

a
t(Model$sigmoidalModel)
```

For genes that are upregulated like gadB, the model appears to fit the data well and provides useful output regarding parameter values and their standard errors. However, for genes like talB (impulse and downregulated), the model doesn't know how to fit them well. This may warrant investigation: how to tweak the code to include downregulaetd genes. There are also many useful vignettes that come with the package that can explain the functions in more detail.  

The last important thing to mention is that there are many transformations that have been developed to normalize RNA-seq data for linear modeling. In my attempts to normalize the data to apply the least squares approach, I successfully did psuedocounts and a voom transform. However, fitting models to these transformed data means that the sigmoid and impulse models no longer fit. More consideration may need to be invested in this step.  

```{r Making the data more normal Plots, echo=FALSE, eval=F, cache=TRUE, warnig=FALSE}
#plot the read count histogram
dim(normecounts)
melt(normecounts[,grep("JH01", colnames(normecounts))]) %>% ggplot(aes(x=value))+geom_histogram(binwidth=10)+xlim(0,1000)+ylim(0,5000)

#pseudocounts: log2(normalized count+1)
melt(normecounts[,grep("JH01", colnames(normecounts))]) %>% mutate(time=ifelse(variable %in% c("JH01_A01", "JH01_B01", "JH01_C01"), 0, ifelse(variable %in% c("JH01_A02", "JH01_B02", "JH01_C02"), 30, ifelse(variable %in% c("JH01_A03", "JH01_B03", "JH01_C03"), 60, ifelse(variable %in% c("JH01_A04", "JH01_B04", "JH01_C04"), 90, ifelse(variable %in% c("JH01_A05", "JH01_B05", "JH01_C05"), 120, ifelse(variable %in% c("JH01_A06", "JH01_B06", "JH01_C06"), 150, NA))))))) %>% ggplot(aes(x=log2(value+1)))+geom_histogram(binwidth=0.1)+xlim(-5,20)+geom_density(color="cyan")+facet_wrap(~time)

#Voom
stoebeldesign<-data.frame(Sample=colnames(ecounts), Condition=c(rep("case",6), rep("control",6), rep("case",6), rep("control",6), rep("case",6), rep("control",6)), Time=rep(c(0,30,60,90,120,150),6))
design=cbind(c(rep(1,6), rep(0,6), rep(1,6), rep(0,6), rep(1,6), rep(0,6)), rep(seq(0,150,30), 3))
voom_res<-voom(normecounts, design)
melt(voom_res$E[,grep("JH01", colnames(voom_res$E))]) %>% mutate(time=ifelse(Var2 %in% c("JH01_A01", "JH01_B01", "JH01_C01"), 0, ifelse(Var2 %in% c("JH01_A02", "JH01_B02", "JH01_C02"), 30, ifelse(Var2 %in% c("JH01_A03", "JH01_B03", "JH01_C03"), 60, ifelse(Var2 %in% c("JH01_A04", "JH01_B04", "JH01_C04"), 90, ifelse(Var2 %in% c("JH01_A05", "JH01_B05", "JH01_C05"), 120, ifelse(Var2 %in% c("JH01_A06", "JH01_B06", "JH01_C06"), 150, NA))))))) %>% ggplot(aes(x=value))+geom_histogram(binwidth=0.1)+xlim(-5,20)+facet_wrap(~time)


###
#Natural log transform
###
ln_sigmoid_function<-function(I, B, t_1, t){log(I)-log(exp(-B*(t-t_1))+1)}
start=list(I=runif(1, 10,13), B=runif(1, 0,20), t_1=runif(1,0,150))
ZABfit <- nls(y ~ ln_sigmoid_function(I,B,t_1,t=dat$t), data= dat, start=start, control=list(maxiter=100))
  
  
#### 
#extra
####
  

vecCounts<-normecounts[grep(gene, rownames(normecounts)), grep("JH01", colnames(normecounts))]
dat<-data.frame(intensity=unlist(c(vecCounts)), time=vecTimepoints)
norm_dat<-normalizeData(dataInput=dat, dataInputName="sigmoidal")
plot(norm_dat$time, norm_dat$intensity)
hist(norm_dat$timeIntensityData$intensity)

sigmoidalModel <- multipleFitFunction(dataInput=norm_dat,
                                      model="sigmoidal")


plot(rep(seq(0,150,30), 3), vecCounts)
lines(seq(0,150,1), sicegar::sigmoidalFitFormula(seq(0,150,1), sigmoidalModel$maximum_Estimate, sigmoidalModel$slopeParam_Estimate, sigmoidalModel$midPoint_Estimate), "l")

plot(seq(0,150,1), log2(sicegar::sigmoidalFitFormula(seq(0,150,1), sigmoidalModel$maximum_Estimate, sigmoidalModel$slopeParam_Estimate, sigmoidalModel$midPoint_Estimate)), "l")
```